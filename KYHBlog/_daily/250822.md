# 파일 및 폴더의 이동을 구현하는 방식 고민

- 기존 방식(MongoDB 썼을때의 방식)

    - 새 부모 디렉토리의 OId, 그곳에서의 새로운 인덱스를 받는다.

    - 기존 부모 디렉토리, 새 부모 디렉토리의 자식 폴더들의 배열만 바꾼다.

- MySQL 에서의 문제점

    - Directory 테이블에는 자식 디렉토리의 정보가 존재하지 않는다.

        - 자식 디렉토리가 부모 디렉토리의 OId 데이터를 갖는다.

    - 자식 디렉토리 배열을 바꾸기 위해선 자식 디렉토리들을 불러오는 쿼리를 먼저 실행하고, 이후에 수정하는 쿼리를 실행해야 한다.
        
        - 자식폴더 배열 정보를 가져오고 수정해야 하기 때문(SELECT 이후 UPDATE)
        - 불필요한 SELECT 쿼리가 실행된다고 생각함.

- 해결방안

    - 클라이언트가 서버에 전송하는 데이터 수정

        - Before
            
            - moveDirOId: 움직일 폴더의 OId
            - dirIdx: 새로운 부모 폴더의 몇 번째 인덱스로 가는지
            - parentDirOId: 새로운 부모 폴더의 OId

        - After

            - moveDirOId: 움직일 폴더의 OId
            
                - 이거 없어도 정상작동은 한다.
                - 로깅을 위해 넘겨준다.
            - oldParentDirOId: 기존 부모 폴더의 OId
            - oldParentChildArr: 폴더 이동후 기존 부모 폴더의 자식 폴더 목록
            - newParentDirOId: 새로운 부모 폴더의 OId
            - newParentChildArr: 폴더 이동후 새로운 부모 폴더의 자식 폴더 목록

    - 설명

        - 이렇게 바꾸면 자식 디렉토리 배열을 바꾸기 위해 SELECT 쿼리를 쓸 필요 없이 UPDATE 쿼리 하나씩만 써도 된다.
        
        - 같은 부모 폴더 내에서 인덱스만 바꾼 경우면 UPDATE 쿼리를 2번이 아닌 1번만 쓰도록 할 수 있다

        

- Trade-Off

    - http 요청시 전송하는 데이터의 크기가 커진다는 단점이 있지만, 그 수치가 미미하고 서버 오버헤드 줄어드는 부분이 훨씬 큼  


# 폴더 이동 관련 쿼리 고민

- 폴더의 이동을 한 폴더의 자식폴더 배열을 바꾸는 문제로 바꿨다.

    - 상단의 "팡리 및 폴더의 이동을 구현하는 방식 고민" 에 설명

- ## 문제 및 해결

    1. 문제 1: 배열에 들어있는 폴더들의 dirIdx 를 배열의 인덱스로 어떻게 바꿀까?

        - 원하는것

            1. 하나의 쿼리로 실행하고싶다.

        - 해결

            1. WHERE dirOId IN(?) 을 사용하여 디렉토리의 배열을 넘겨준다.
            2. SET 구문에 CASE 문을 적용하여 dirOId 마다 설정해줄 dirIdx 를 넘겨준다.

    2. 문제 2: 디렉토리들의 parentOId 를 바꾸는 쿼리를 또 실행해야하나?

        - 원하는것
            
            1. [문제 1] 이랑 같은 쿼리로 실행하고 싶다.

        - 해결

            1. SET 구문에 parentDirOId 를 추가
    
    3. 문제 3: dirOId 폴더의 배열길이 업데이트 하는 쿼리도 실행해야한다.

        - 원하는것

            1. 성능(속도) 개선

        - 해결

            1. [문제 1] 및 [문제 2] 에서 작성한 쿼리랑 Promise.all 로 묶어서 비동기로 실행
            2. 후에 정보 읽는 쿼리들도 비동기로 실행행

        