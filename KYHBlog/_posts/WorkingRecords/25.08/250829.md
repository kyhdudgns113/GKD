<div class="block_red">

## **채팅이 먼저냐 댓글이 먼저냐?**

<div class="block_half_transparent">

### **채팅을 먼저 하기로 결정함**

- #### 어차피 댓글 구현할때 채팅보내기 기능도 넣어야 한다.

- #### 댓글을 먼저 구현하게 되면 다음과 같이 일을 해야 한다.

    + 댓글 기능만 구현

    + 채팅 기능 구현

    + 댓글 유저한테 채팅보내는 기능 구현

- #### 이렇게 하면 Context Switching 이 두 번 일어나게 되어 비효율적이다.

</div>

</div>

<div class="block_green">

## **채팅 데이터 관리방법 고민**

<div class="block_half_transparent">

### **동시성 문제는 해결이 되었다.**

- 자체적으로 개발한 Mutex Lock 기능을 사용하면 된다.

</div>

<div class="block_half_transparent">

### **채팅에 인덱스를 넣을까 말까**

<div class="block_half_transparent">


1. #### **채팅 테이블에 chatIdx 를 AUTO INCREMENT 로 한다.**

    - ##### 장점

        1. 테이블 쿼리가 단순해짐

        2. 채팅 생성시 쿼리 및 성능 개선

    - ##### 단점

        1. 최근 몇개의 채팅 검색하는 성능 저하

            - 채팅방 내의 모든 채팅을 읽어오고 거기서 분류한다면 그에 따른 오버헤드 발생

            - 쿼리로 해결한다면 DB 서버에서 오버헤드 발생

</div>

<div class="block_half_transparent">

2. #### **채팅방 테이블을 따로 만들고 채팅방의 채팅갯수를 별도로 관리. 이것을 읽어와서 인덱스로 쓴다.**

    - 장점

        1. 동시성 문제는 Mutex Lock 을 쓰면 된다.

        2. 구간별 채팅 읽어올때 채팅마다 인덱스를 활용할 수 있어서 성능 개선

    - 단점

        1. 채팅을 할 때마다 채팅방 테이블도 검색 및 업데이트를 해야함

        2. Mutex Lock 을 써야만 하기에 여기에서 오버헤드 발생

</div>

</div>

<div class="block_half_transparent">

### **고려하는것**

<div class="block_half_transparent">

#### **채팅방에는 2명만이 참여한다.**

+ 블로그 서비스에서 다중 이용자의 채팅기능을 고려할 필요는 없다.

</div>

<div class="block_half_transparent">

#### **채팅 서비스는 1대의 서버에서만 돌아간다.**

+ 최소한 블로그 서비스에서는 채팅기능을 수행하는 여러대의 서버를 필요로 하지 않는다.

</div>

<div class="block_half_transparent">

#### **Mutex Lock 은 어차피 써야한다.**

+ 채팅이 도착한 순서대로 DB 에 저장이 되는것이 좋다.
    
+ 채팅이 저장된 순서대로 채팅방에 떠야한다.

+ 채팅이 도착하면 채팅방에 대한 Mutex Lock 을 획득하도록 하는것이 좋다.

</div>

<div class="block_half_transparent">

#### **채팅 읽기보다 채팅 하기를 훨씬 더 많이 시도한다.**

+ 채팅 읽기 한 번에 10개 이상씩 읽어오기 때문에 자주 수행하지 않는다.

+ 채팅 하기는 실시간으로 수행되는 경우가 있어서 이 때의 속도가 더 중요하다.

</div>

<div class="block_half_transparent">

#### **안 읽은 메시지 개수도 고려해야 한다.**

+ 유저가 속한 채팅방마다 안 읽은 메시지 개수도 알아야 한다.

+ 이를 위해선 별도의 테이블을 만들어야 한다.

</div>

<div class="block_half_transparent">
      
### **결론**

- 일단 서버에서 채팅을 처리하는 방식부터 고민하자

</div>

</div>

<div class="block_blue">        

## **서버에서 채팅 처리하는 방법 고민**

#### 서버에 Socket 으로 들어오는 채팅들을 어떻게 순차적으로 처리할지 방법에 대한 고민

<div class="block_half_transparent">

### **다음 3가지 방법이 생각났다.**

<div class="block_half_transparent">

1. #### **채팅이 수신되면 채팅방에 대한 Mutex Lock 을 획득할때까지 기다리게 하기**

    - 채팅방마다 병렬적으로 작동할 수 있음

    - Mutex Lock 획득했는지 확인하는 오버헤드 발생

</div>

<div class="block_half_transparent">

2. #### **채팅이 수신되면 채팅 Queue 에 넣고 순차적으로 처리하기**

    - 채팅이 들어오면 채팅방과 상관없이 순서대로 처리하겠다는 의미

    - 채팅방 상관없이 하나의 채팅에 대한 처리가 끝나야 다음 채팅을 처리함

    - 3번보다 구현은 확실히 편해짐

    - 서로 다른 채팅방에 대하여 병렬적으로 이루어지지 않게됨. (속도 저하)

</div>

<div class="block_half_transparent">

3. #### **채팅이 수신되면 채팅방의 Queue 에 넣고 순차적으로 처리하기**

    - 채팅방마다 수신된 채팅들을 순서대로 처리하겠다는 의미

    - 하나의 채팅방에 대해서, 하나의 채팅이 처리되면 다음 채팅을 처리함.

    - 채팅방마다 병렬적으로 작동할 수 있음

    - 채팅방의 Queue 의 Life Cycle 을 관리해야함.

</div>

</div>

<div class="block_half_transparent">

### **3가지 방법에 대한 고민거리**

- #### **2번은 폐기한다.**

    - 서로 다른 채팅방들에 대해서 동기적으로 작업이 수행되는 꼴

    - 서로 다른 채팅방의 채팅까지 순서를 맞춰서 실행해야 할 필요는 없다.

- #### **1번은 Mutex Lock 확인하느라 오버헤드가 심하다.**

- #### **3번은 Queue 의 Life Cycle 관리하는 오버헤드가 발생한다.**

</div>

<div class="block_half_transparent">

### **결론**

- 메시지 큐 쓰자.

</div>

</div>

    



