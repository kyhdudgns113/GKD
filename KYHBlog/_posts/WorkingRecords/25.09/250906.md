<div class="block_white">

## **새 알람 확인 기능**

<div class="block_grey">

### **알람 기능 개요(클라이언트 관점)**

#### **다음 상황에서 알람이 생성된다.**

- 내가 작성한 게시글에 댓글이 달린 경우

- 내가 작성한 댓글에 대댓글이 달린 경우

- 누군가가 나를 태그한 대댓글을 단 경우

#### **생성된 알람은 "새 것" 상태가 된다.**

- 페이지 오른쪽 상단에 그 갯수가 표시된다. (1개 이상인 경우)

#### **상단의 알람 아이콘을 클릭하면 "새 것" 상태에서 "헌 것" 상태로 바뀐다.**

#### **각 알람을 클릭하면 알람이 발생한 게시글로 페이지를 이동한다.**

</div>

<div class="block_grey">

### **원하는 기능**

#### **알람 아이콘을 눌러서 알람 목록이 표시될때**
    
- 가장 최근 알람을 맨 위에 배치

- "새 것" 이었던 알람은 그대로 "새 것" 상태로 표시

- "새 것" 상태였던 알람들을 "헌 것" 상태로 전환

    + http 의 PUT 요청

#### **알람 목록을 켰다가 끌 때(혹은 꺼져있을때)**

- 오른쪽 상단에 표시된 "새 것" 의 갯수를 재설정

    + 실시간으로 들어오는 알람이 있을 수 있기에 꼭 0은 아니다.

- 유저의 알람 목록 불러오기

    + http 의 GET 요청

#### **목록 표시여부와 무관하게**

- 실시간으로 들어오는 알람은 알람목록 맨 위에 계속해서 추가

</div>

<div class="block_red">

### **문제**

#### **앱의 state 와 dependency 관리 문제 발생**

- 정말 최대한 dependency 에는 뭔가를 추가하지 않으려고함

    + 리렌더링 성능 이슈가 가장 큼

    + 함수의 경우 인자에 포함하는 식으로 해결해왔음

    + 상태의 변화에 의해 반응해야하는 경우만 dependency 에 추가하려고 해왔음

        * 주로 useEffect

- dependency 에 알람 배열을 추가하지 않고 구현을 원함

    + 알람이 실시간으로 올 때 마다 useCallback 함수등을 재설정 하는것을 방지하고자 함

</div>

<div class="block_orange">

### **1번째 방법(채택 X)**

#### **방법**

- 알람 목록 표시를 On/Off 나 Toggle 하는 함수에 다음 값을 인자로 추가함

    + 알람 목록 On/Off 상태 변수

- 위 변수값에 따라서 PUT 요청이나 GET 요청을 수행

    + 상단의 **원하는 기능** 에 설명

#### **한계점**

- 페이지 최상단 컴포넌트에 onClick 메소드에 알람 목록 표시 Off 함수를 사용한다.

- 이 함수에 바로 위에서 언급한 변수를 넣으려면, 상위 함수의 인자로 넣거나, Dependency 에 추가해야함.

    + 상위 함수 인자 예시

        * ```ts
          const onClickBackground = useCallback((isAlarmOpen: boolean) => {
            // 다른 함수들
            closeAlarmModal(isAlarmOpen)
            // 다른 함수들
          }, [])
          ```

    + Dependency 에 추가 예시

        * ```ts
          const onClickBackground = useCallback(() => {
            // 다른 함수들
            closeAlarmModal(isAlarmOpen)
            // 다른 함수들
          }, [isAlarmOpen])
          ```

- 이런식으로 구현하면 앞으로 비슷한 일이 발생할때 반복하게됨

    + 코드 가독성 감소

    + 불필요한 

</div>

<div class="block_yellow">

### **2번째 방법(채택 X)**

#### **방법**

- 컴포넌트가 Mount 되면 GET 요청, Unmount 되면 PUT 요청을 한다.

    + GET 요청: 알람 목록 불러오기

    + PUT 요청: "새 것" 알람들을 "헌 것" 으로 바꾸기

#### **한계점**

- PUT 요청에 알람배열을 인자로 전달하는 경우

    + 코드 예시

    + ```ts
      useEffect(() => {

        return () => {
          PUT_change_new_to_old(alarmArr)
        }
      }, [alarmArr])
      ```

    + alarmArr 가 dependency 에 들어간다.

    + 실시간으로 알람이 올 때마다 useEffect 의 return 함수가 실행되어 PUT 요청을 하게된다.

- PUT 요청의 Dependency 에 알람 배열을 넣는 경우

    + 위의 코드와 마찬가지로 알람 배열이 바뀔때마다 PUT 요청 함수가 바뀐다.

    + PUT 요청 함수가 바뀔때마다 useEffect 의 return 함수가 실행된다.

</div>

<div class="block_green">

### **3번째 방법(채택 O)**

#### **방법**

- 알람 배열을 useState 와 useRef 로 관리

    + useState 는 컴포넌트 마운트용

    + useRef 는 PUT 함수의 인자 전달용

- Context Provider 에서 내보내는 함수 수정

    + 기존에는 useState 의 SetStateAction 을 그대로 내보냄

    + useRef 값도 수정하도록 조정

#### **Trade-Off**

- useRef 도 사용하여 메모리 소비량 증가

</div>

</div>