<div class="block_white">

## **개요**

- #### 토큰을 탈취당해도 보안을 유지할 수 있는 토큰 인증 알고리즘

- #### 추가 http 요청을 수행하여 토큰 탈취에 대한 안정성 확보

- #### 어떤 단계에서 토큰이 탈취되어도 토큰 사용이 불가능함

</div>

<div class="block_grey">

## **서론**

### **서버와 클라이언트간 통신을 할 때 개인 인증정보를 확인할 수단이 필요**

- #### 어떤 유저가 요청을 하는지 정보를 알아야 한다.

<br />

### **유저의 아이디와 비밀번호를 직접 전달하는건 매우 위험하다.**

- #### 중간에 이 정보다 탈취당하면 유저의 개인정보가 고스란히 넘겨진다.

<br />

### **그래서 웹서비스들은 토큰이나 세션등의 인증방식을 사용한다.**

- #### **토큰방식**

    + 서버가 유저의 인증정보를 암호화하여 클라이언트에게 넘겨준다.

    + 클라이언트는 이를 보관하고 있다가 인증이 필요할때 토큰을 서버에게 넘겨준다.

    + 서버는 이를 복호하여 인증 정보를 확인한다.

    + 로그인 여부를 클라이언트가 저장하고 이를 서버가 확인하는 방식

- #### **세션 방식**

    + 서버는 유저의 인증정보를 확인하고 임의의 Key 를 만들어 저장한다.

    + 클라이언트에게 이 Key 를 전달하고, 클라이언트는 인증이 필요할때 이 Key 를 서버에 전달한다.

    + 서버는 요청이 올 때 마다 해당 Key 를 확인하고 로그인 상태인지 파악한다.

    + 로그인 여부를 서버가 저장하고 이를 확인하는 방식

<br />

### **토큰 방식의 장단점**

- #### **장점**

    1. 서버에 별도로 저장하는것이 없어서 서버 부담 감소

    2. 인증 확인시 DB 접근을 안해도 되어 서버 비용 감소

    3. 서버가 여러대여도 인증 확인이 용이함
    
- #### **단점**

    1. 서버가 해당 토큰 자체를 막을 방법이 없음

    2. 토큰 탈취시 인증 요청을 막지 못함

<br />

### **아이디어**

- #### 토큰 탈취를 원천적으로 막을수는 없다.

- #### 토큰을 탈취해도 못 쓰게 할 수는 없을까?

- #### 암호화 되어있는 토큰에 암호화를 한 번 더 적용하자

</div>

<div class="block_white">

## **GKDoubleJWT 알고리즘 요약**

<div class="block_red_transparent">

### **로그인시**

- #### 서버는 JWT 를 암호화하여 **[보관용 토큰]** 을 만들고 이를 클라이언트로 보낸다.

    + 서버가 클라이언트에게 퀴즈를 내는것과 유사하다.

- #### 클라이언트는 **[보관용 토큰]** 을 저장한다.

</div>

<div class="block_green_transparent">

### **인증 요청시**

- #### 클라이언트가 A 라는 url 로 인증요청을 하는 상황이다.

- #### 클라이언트는 **[보관용 토큰]** 을 복호 및 암호화하여 서버의 **[인증용 URL]**에  전송한다.

    + 클라이언트가 퀴즈를 풀고 답지를 제출하는 형태다.

- #### 서버는 이를 복호하고 토큰 검증을 한다.

    + 서버가 퀴즈를 채점하는 형태다.

- #### 서버는 새로운 JWT 를 생성한 뒤 암호화하여 **[인증용 토큰]**을 만들고 전송한다.

    + 서버는 다시 퀴즈를 낸다.

- #### 클라이언트는 **[인증용 토큰]** 을 다시 복호 및 암호화하여 원하는 url A 에 요청을 한다.

    + 클라이언트는 다시 퀴즈를 풀어서 제출한다.

- #### 서버는 이를 검증하고 유효하면 요청을 수행한다.

</div>

</div>

<div class="block_grey">

## **GKDoubleJWT 알고리즘**

<div class="block_red">

### **로그인시**

<div class="block_blue">

#### **1.** **[Server]** 유저로부터 받은 정보로 JWT 를 만든다.

#### **2.** **[Server]** 길이가 a 인 임의의 Header 를 만든다.

- 길이 a 는 클라이언트와 공유한다.

#### **3.** **[Server]** Header 를 JWT 에 부착하여 **aJWT** 형태로 만들고 전송한다.

- 이를 **[보관용 토큰]** 이라 한다.

</div>

<div class="block_yellow">

#### **4.** **[Client]** 서버로부터 받은 **[보관용 토큰]** 을 저장한다.

</div>

</div>

<div class="block_green">

### **인증 요청시**

- #### 클라이언트가 A 라는 URL 로 인증요청을 하려는 상황이다.

<div class="block_yellow">

#### **A1.** **[Client]** **[보관용 토큰]** 에서 Header 를 추출한다.

#### **A2.** **[Client]** 추출한 Header 를 이용하여 Footer 를 만든다.

- Footer 생성시 임의의 알고리즘을 사용하고, 이는 서버와 공유한다.

#### **A3.** **[Client]** Footer 를 **[보관용 토큰]** 에 붙여 **aJWTa** 형태를 만든다.

#### **A4.** **[Client]** 이 토큰을 요청하는 URL 정보인 A 와 함께 서버의 **[인증용 URL]** 에 요청으로 보낸다.

</div>

<div class="block_blue">

#### **B1.** **[Server]** 수신한 토큰 **aJWTa** 로부터 Header 와 Footer 를 추출한다.

#### **B2.** **[Server]** Header 와 Footer 의 무결성을 검증한다.

- Header 로 Footer 를 만들 수 있는지 확인한다.

#### **B3.** **[Server]** JWT 검증을 하고 새로운 JWT 를 만든다.

#### **B4.** **[Server]** 길이 b 인 임의의 Header 를 만들고 JWT 에 부착하여 **bJWT** 형태를 만든다.

- 이를 **[인증용 토큰]** 이라 한다.

- 길이 b 도 클라이언트와 공유한다.

#### **B5.** **[Server]** 해당 토큰을 Key, 요청 URL 인 A 를 Value 로 하는 매핑 정보를 저장한다.

#### **B6.** **[Server]** **[인증용 토큰]** 을 클라이언트로 전송한다.

</div>

<div class="block_yellow">

#### **C1.** **[Client]** 수신받은 **[인증용 토큰]** 에서 Header 를 추출한다.

#### **C2.** **[Client]** 추출한 Header 로 Footer 를 만들고 **[인증용 토큰]** 에 붙인다.

- **bJWTb** 형태가 만들어진다.

- 여기서 Footer 를 만드는 알고리즘 역시 서버와 공유한다.

#### **C3.** **[Client]** 원하는 URL 인 A 에 **bJWTb** 를 전송한다.

</div>

<div class="block_blue">

#### **D1.** **[Server]** 수신받은 **bJWTb** 에서 Header 와 Footer 를 추출한다.

#### **D2.** **[Server]** 추출한 Header 로 추출한 Footer 를 만들 수 있는지 검증한다.

#### **D3.** **[Server]** 서버에 저장되어있는 매핑정보에서 수신받은 **bJWT**, 그리고 요청 URL 이 일치하는지 검증

#### **D4.** **[Server]** 검증되었으면 매핑정보를 지운다.

#### **D5.** **[Server]** 새로운 **[보관용 토큰]** 인 **aJWT** 를 만들고 응답과 함께 전송

</div>

</div>

</div>

<div class="block_white">

## **토큰 탈취 상황들**

- #### 토큰이 탈취될 수 있는 경우들에 대한 설명이다.

- #### 모든 탈취 상황에 대해서 안전함을 설명한다.

<div class="block_red">

### **aJWT** 가 탈취되었을때

- #### 로그인이나 요청 이후 서버가 송신하는 **[보관용 토큰]** 이 탈취된 경우

- #### 해커는 aJWT 로부터 Header 와 JWT 를 추출하지 못한다.

    + 애초에 추출을 해야한다는 생각 자체를 하기 힘들다.

    + 했다 하더라도 Header 의 길이를 모르면 추출을 정상적으로 할 수 없다.

- #### 추출을 했다 하더라도 Header 로부터 Footer 를 만드는 방법을 모른다.

    + Footer 를 붙여야 한다는것도 알기 힘들다.

    + Footer 를 만드는 알고리즘도 알지 못한다.

- #### 인증용 URL 에만 보내야 한다는것도 알기 힘들다.

    + 길이 a 인 Header 와 Footer 로는 [인증용 URL] 에서만 사용이 가능하다.

    + 다른 URL 들은 길이 b 인 Header 와 Footer 만 사용 가능하다.

</div>

<div class="block_yellow">

### **aJWTa** 가 탈취되었을때

- #### 클라이언트가 서버에 전송할때 탈취된 경우

- #### 이 토큰은 [인증용 URL] 에서만 유효하며, 다른 URL 에서는 사용 불가능하다.

    + 다른 URL 에서 사용시 D1 단계에서 인증이 실패한다.

- #### 또한 [인증용 URL] 에 요청할때, 원래 요청 URL 을 붙여서 보내야 하는것도 모른다.

    + B5 단계에서 인증이 실패한다.

- #### [인증용 URL] 로 해커가 전송을 했다고 하더라도 그 이후 수신받는 **bJWT** 를 활용하지 못한다.

</div>

<div class="block_green">

### **bJWT** 가 탈취되었을때

- #### 서버가 전송하는 **[인증용 토큰]** 이 탈취되거나, 해커가 **aJWTa** 로 수신받았을때

- #### **bJWT** 에서 Header 를 추출하지 못한다.

    + 보관용 토큰과 인증용 토큰의 Header 길이가 다르며, 이를 알고있어야 한다.

- #### 추출했다 하더라도 Footer 를 만들지 못한다.

    + Footer 를 또 만들어야 한다는 생각을 하기도 힘들다.

    + 했다고 하더라도 Footer 를 만드는 알고리즘을 모른다.

- #### Footer 를 만들었다 하더라도 서버에 매핑된 URL 로 전송해야만 인증이 성공한다.

</div>

<div class="block_blue">

### **bJWTb** 가 탈취되었을때

- #### 클라이언트가 원하는 URL 에 전송하는 토큰이 탈취된 경우

- #### 해커는 해당 토큰이 어느 URL 에 매핑되었는지 맞춰야 한다.

    + B5 에서 저장한 매핑정보를 맞춰야 한다.

- #### 맞췄다고 하더라도 클라이언트가 이미 사용해서 매핑정보가 지워졌다.

    + D4 에서 이미 매핑정보를 제거했다.

    + 여기에서 해커가 토큰을 사용하려고 해도 인증이 실패하게 된다.

</div>

</div>